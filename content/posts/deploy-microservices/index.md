---
title: 'Deploying Microservices with Traefik'
date: 2020-05-02
description: 'A detailed walkthrough of how to deploy multiple docker services using Traefik as reverse proxy'
tags:
  [
    'microservices',
    'Traefik',
    'DevOps',
    'software-development',
    'web',
    'Docker',
  ]
---

I've been running this blog on a bare-metal server using [Nginx](https://www.nginx.com/) as a reverse proxy to basically serve the static files generated by Gatsby. But now I want to deploy multiple docker services on my [VPS](https://en.wikipedia.org/wiki/Virtual_private_server). So I decided try using Traefik, which is an edge router that can act as a reverse proxy and route multiple services on my personal domain. Unfortunately, my brain is not big enough to understand all these new concepts. So, I decided to document it.

## Goals

First, I should probably plan out what the goals are so I can figure out how to get there:

- Run multiple containerised services on my domain under different subdomains, mainly [blog.imranc.io](https://blog.imranc.io) for now
- HTTPS everywhere

There, that seems pretty simple. So lets get on with it.

## Primer

Just a quick primer on some of the technologies being used for deployment:

- [**Traefik**](https://containo.us/traefik/) is an open-source edge router that will handle web requests sent to my domain
- [**Docker**](https://www.docker.com) is platform-as-a-service software that uses OS-level virtualisation to deliver software in _containers_
- [**Docker Compose**](https://docs.docker.com/compose/) is a tool for orchestrating multi-container applications using YAML config files

## Containerising My Blog

[_Containerisation_](https://hackernoon.com/what-is-containerization-83ae53a709a6) is the concept of bundling an application together with all of its related configuration files, libraries and dependencies required for it to run effeciently across a variety of different computing environments. I have chosen Docker to containerise my applications because I'm slightly familiar with it from work and it's been all the rage in DevOps for quite a while now.

Currently, the way I've been deploying changes to my blog is the following:

1. Make new markdown files in my blog [repo](https://github.com/imrancio/blog)
2. Commit changes and push to GitHub
3. Use `gatsby-cli` to build production files
4. Production files get symlinked to Nginx site folders
5. Nginx serves new production files

The problem with that is everything after 3 is a bit limiting. Nginx requires a lot of fiddling around with to configure everything correctly. I have to write server code for every application I want deployed and it's been years since I messed around with Nginx.

Docker simplifies the process of setting up a server to serve static files for my blog. Nginx itself is a containerised service in Docker Hub. That means using Docker Compose, it's quite easy to set up my blog as a service that builds all the Gatsby static files and serves them on my domain using a single configuration file.

```Dockerfile
ARG GATSBY_ACTIVE_ENV=production
FROM node:12-alpine AS build

RUN yarn global add gatsby-cli
ARG GATSBY_ACTIVE_ENV
ENV GATSBY_ACTIVE_ENV=$GATSBY_ACTIVE_ENV

WORKDIR /app
ADD . ./
RUN yarn install
RUN gatsby build

FROM nginx
COPY --from=build /app/public /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
```

This single `Dockerfile` above is all I need in my blog repository to build the Docker image for my blog, along with a `.dockerignore` file to optimise what's included in my blog service.

Essentially, what it does is the following:

#### On a minimal Node.js Docker image

1. Installs `gatsby-cli`
2. Copies over all my blog src code, excluding any assets that will be built later
3. Installs all the packages required to build my blog
4. Runs `gatsby build` to build static files for my blog

#### On an Nginx server Docker image

5. Copies over static Gatsby files from Node.js image
6. Copies over Nginx config to run the server
7. Server is exposed via HTTP (port 80)

In Docker, you can start from a variety of base _images_. These are basically minimal OSes with certain packages and applications pre-installed. Then, you keep adding _layers_ to this base image by running each command in the `Dockerfile` to build your service. Finally, you can use Docker Compose to spin up multiple _containers_ running from these built _images_.

## Traefik Routing

Now that my blog has been built into a Docker _image_, I can deploy my blog in a Docker _container_. The magic with all this is that Traefik, which is a service for routing to other services, can also run in a Docker _container_. This means all of my services will run in Docker containers and I can configure them all in a single `docker-compose.yaml` file.

The following is part of the `docker-compose.yaml` file used to orchestrate multiple services in my domain using Docker Compose:

```yaml
version: '3.3'

services:
  traefik:
    image: traefik:v2.2
    container_name: traefik
    command:
      # highlight-start
      # HTTP -> HTTPS entrypoint redirection
      - '--entrypoints.web.address=:80'
      - '--entrypoints.web.http.redirections.entryPoint.to=websecure'
      - '--entrypoints.web.http.redirections.entryPoint.scheme=https'
      - '--entrypoints.websecure.address=:443'
      # Docker provider
      - '--providers.docker=true'
      # Traefik Console
      - '--api=true'
      # Let's Encrypt certificate resolver
      - '--certificatesresolvers.leresolver.acme.tlschallenge=true'
      - '--certificatesresolvers.leresolver.acme.email=ACME_EMAIL'
      - '--certificatesresolvers.leresolver.acme.storage=/letsencrypt/acme.json'
      # highlight-end
    ports:
      - '80:80'
      - '443:443'
    volumes:
      # Persist Let's Encrypt certificates
      - './letsencrypt:/letsencrypt'
      # For Docker service discovery
      - '/var/run/docker.sock:/var/run/docker.sock:ro'
    labels:
      # highlight-start
      - 'traefik.http.routers.api.rule=Host(`traefik.imranc.io`)'
      - 'traefik.http.routers.api.entrypoints=websecure'
      - 'traefik.http.routers.api.tls.certresolver=leresolver'
      - 'traefik.http.routers.api.service=api@internal'
      - 'traefik.http.routers.api.middlewares=auth'
      - 'traefik.http.middlewares.auth.basicauth.users=BASIC_AUTH_USERNAME:PASSWORD_STRING'
      # highlight-end

  blog:
    image: blog
    container_name: imrancio-blog
    labels:
      # highlight-start
      - 'traefik.enable=true'
      - 'traefik.http.routers.blog.rule=Host(`blog.imranc.io`)'
      - 'traefik.http.routers.blog.entrypoints=websecure'
      - 'traefik.http.routers.blog.tls.certresolver=leresolver'
      # Routes from root imranc.io
      - 'traefik.http.routers.root.rule=Host(`imranc.io`)'
      - 'traefik.http.routers.root.entrypoints=websecure'
      - 'traefik.http.routers.root.tls.certresolver=leresolver'
      - 'traefik.http.routers.root.middlewares=redirect-to-blog'
      # Routes from www.imranc.io
      - 'traefik.http.routers.www.rule=Host(`www.imranc.io`)'
      - 'traefik.http.routers.www.entrypoints=websecure'
      - 'traefik.http.routers.www.tls.certresolver=leresolver'
      - 'traefik.http.routers.www.middlewares=redirect-www-to-blog'
      # imranc.io -> blog.imranc.io middleware
      - "traefik.http.middlewares.redirect-to-blog.redirectregex.regex=^https?:\\/\\/(imranc\\.io)+(.*)$$"
      - 'traefik.http.middlewares.redirect-to-blog.redirectregex.replacement=https://blog.$${1}$${2}'
      # www.imranc.io -> blog.imranc.io middleware
      - "traefik.http.middlewares.redirect-www-to-blog.redirectregex.regex=^https?:\\/\\/www\\.(imranc\\.io)+(.*)$$"
      - 'traefik.http.middlewares.redirect-www-to-blog.redirectregex.replacement=https://blog.$${1}$${2}'
      # highlight-end
```

There's a lot going on there but the main thing to note is there are 2 services, **traefik** and **blog**:

- Traefik service is configured in the `commands` section and all the Traefik routes for services are configured via their respective `labels` sections
- There is a route setup for Traefik Dashboard at [traefik.imranc.io](https://traefik.imranc.io), which is hidden behind a basic auth wall.
- There is a route setup for my blog server image at [blog.imranc.io](https://blog.imranc.io)
- There's some redirect routes setup for [imranc.io](https://imranc.io) and [www.imranc.io](https://www.imranc.io), which both point to [blog.imranc.io](https://blog.imranc.io)

The idea is I can keep adding services here and routing them all via `labels` with very little configuration required.

## Additional Services

As an example of additional services I can deploy, I went ahead and set up my own self-hosted instance of [Bitwaden](https://bitwarden.com/) at [bitwarden.imranc.io](https://bitwarden.imranc.io) using the [bitwarden_rs](https://github.com/dani-garcia/bitwarden_rs) Docker image. I am the sole user of the service and have disabled registration. As such, I can store all my credentials in my own server and have it sync across all my devices anywhere in the world from my private vault than no one else can access. I really :heart: that I can do that!
